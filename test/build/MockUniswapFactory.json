{
	"schemaVersion": "2.0.0",
	"contractName": "MockUniswapFactory",
	"compilerOutput": {
		"abi": [
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "token",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "exchange",
						"type": "address"
					}
				],
				"name": "NewExchange",
				"type": "event"
			},
			{
				"constant": false,
				"inputs": [
					{
						"internalType": "address",
						"name": "token",
						"type": "address"
					},
					{
						"internalType": "address payable",
						"name": "exchange",
						"type": "address"
					}
				],
				"name": "createExchange",
				"outputs": [
					{
						"internalType": "address payable",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"internalType": "address",
						"name": "token",
						"type": "address"
					}
				],
				"name": "getExchange",
				"outputs": [
					{
						"internalType": "address payable",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"internalType": "address",
						"name": "exchange",
						"type": "address"
					}
				],
				"name": "getToken",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [
					{
						"internalType": "uint256",
						"name": "token_id",
						"type": "uint256"
					}
				],
				"name": "getTokenWithId",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "tokenCount",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b50610674806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806306f2bf621461005c57806359770438146100e05780639f181b5e14610164578063aa65a6c014610182578063f8e26217146101f0575b600080fd5b61009e6004803603602081101561007257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610294565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b610122600480360360208110156100f657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506102fd565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61016c610366565b6040518082815260200191505060405180910390f35b6101ae6004803603602081101561019857600080fd5b810190808035906020019092919050505061036c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6102526004803603604081101561020657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506103a9565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b6000600260008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60005481565b60006003600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156103e457600080fd5b600073ffffffffffffffffffffffffffffffffffffffff16600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161461047c57600080fd5b81600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600160005401905080600081905550836003600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167f9d42cb017eb05bd8944ab536a8b35bc68085931dd5f4356489801453923953f960405160405180910390a3829150509291505056fea265627a7a723158203a5c13fc5ea7ff6f91590b06f03224174c1d46e6315f6a13269b99f43a08a74264736f6c634300050d0032",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH2 0x674 DUP1 PUSH2 0x20 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x57 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x6F2BF62 EQ PUSH2 0x5C JUMPI DUP1 PUSH4 0x59770438 EQ PUSH2 0xE0 JUMPI DUP1 PUSH4 0x9F181B5E EQ PUSH2 0x164 JUMPI DUP1 PUSH4 0xAA65A6C0 EQ PUSH2 0x182 JUMPI DUP1 PUSH4 0xF8E26217 EQ PUSH2 0x1F0 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x9E PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x72 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x294 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x122 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xF6 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x2FD JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x16C PUSH2 0x366 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x1AE PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x198 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x36C JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x252 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x206 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x3A9 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 PUSH1 0x1 PUSH1 0x0 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x2 PUSH1 0x0 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 PUSH1 0x3 PUSH1 0x0 DUP4 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND SWAP1 POP SWAP2 SWAP1 POP JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ ISZERO PUSH2 0x3E4 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x0 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH1 0x1 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND EQ PUSH2 0x47C JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 PUSH1 0x1 PUSH1 0x0 DUP6 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP3 PUSH1 0x2 PUSH1 0x0 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH1 0x0 PUSH1 0x1 PUSH1 0x0 SLOAD ADD SWAP1 POP DUP1 PUSH1 0x0 DUP2 SWAP1 SSTORE POP DUP4 PUSH1 0x3 PUSH1 0x0 DUP4 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP3 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH32 0x9D42CB017EB05BD8944AB536A8B35BC68085931DD5F4356489801453923953F9 PUSH1 0x40 MLOAD PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 LOG3 DUP3 SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH6 0x627A7A723158 KECCAK256 GASPRICE 0x5C SGT 0xFC 0x5E 0xA7 SELFDESTRUCT PUSH16 0x91590B06F03224174C1D46E6315F6A13 0x26 SWAP12 SWAP10 DELEGATECALL GASPRICE ADDMOD 0xA7 TIMESTAMP PUSH5 0x736F6C6343 STOP SDIV 0xD STOP ORIGIN ",
				"sourceMap": "64:1464:41:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;64:1464:41;;;;;;;"
			}
		}
	},
	"sources": {
		"test-contracts/MockUniswap/MockUniswapFactory.sol": {
			"id": 41
		},
		"test-contracts/MockUniswap/MockUniswapExchange.sol": {
			"id": 40
		},
		"test-contracts/MockUniswap/UniswapERC20.sol": {
			"id": 42
		},
		"@openzeppelin/contracts/GSN/Context.sol": {
			"id": 51
		},
		"@openzeppelin/contracts/token/ERC20/IERC20.sol": {
			"id": 55
		},
		"@openzeppelin/contracts/math/SafeMath.sol": {
			"id": 52
		},
		"test-contracts/MockUniswap/IUniswapFactory.sol": {
			"id": 39
		},
		"test-contracts/MockUniswap/IUniswapExchange.sol": {
			"id": 38
		}
	},
	"sourceCodes": {
		"test-contracts/MockUniswap/MockUniswapFactory.sol": "pragma solidity ^0.5.13;\n\nimport \"./MockUniswapExchange.sol\";\n\n\ncontract MockUniswapFactory {\n\n  /***********************************|\n  |       Events And Variables        |\n  |__________________________________*/\n\n  event NewExchange(address indexed token, address indexed exchange);\n\n  uint256 public tokenCount;\n  mapping (address => address payable) internal token_to_exchange;\n  mapping (address => address) internal exchange_to_token;\n  mapping (uint256 => address) internal id_to_token;\n\n  /***********************************|\n  |         Factory Functions         |\n  |__________________________________*/\n  \n  function createExchange(address token, address payable exchange) public returns (address payable) {\n    require(token != address(0));\n    require(token_to_exchange[token] == address(0));\n    token_to_exchange[token] = exchange;\n    exchange_to_token[exchange] = token;\n    uint256 token_id = tokenCount + 1;\n    tokenCount = token_id;\n    id_to_token[token_id] = token;\n    emit NewExchange(token, exchange);\n    return exchange;\n  }\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  function getExchange(address token) public view returns (address payable) {\n    return token_to_exchange[token];\n  }\n\n  function getToken(address exchange) public view returns (address) {\n    return exchange_to_token[exchange];\n  }\n\n  function getTokenWithId(uint256 token_id) public view returns (address) {\n    return id_to_token[token_id];\n  }\n\n}",
		"test-contracts/MockUniswap/MockUniswapExchange.sol": "pragma solidity ^0.5.13;\n\nimport \"./UniswapERC20.sol\";\nimport \"./IUniswapFactory.sol\";\nimport \"./IUniswapExchange.sol\";\n\n\ncontract MockUniswapExchange is UniswapERC20 {\n\n  /***********************************|\n  |        Variables && Events        |\n  |__________________________________*/\n\n  // Variables\n  bytes32 public name;         // Uniswap V1\n  bytes32 public symbol;       // UNI-V1\n  uint256 public decimals;     // 18\n  IERC20 token;                // address of the ERC20 token traded on this contract\n  IUniswapFactory factory;     // interface for the factory that created this contract\n  \n  // Events\n  event TokenPurchase(address indexed buyer, uint256 indexed eth_sold, uint256 indexed tokens_bought);\n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\n  event AddLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\n  event RemoveLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\n\n\n  /***********************************|\n  |            Constsructor           |\n  |__________________________________*/\n\n  /**  \n   * @dev This function acts as a contract constructor which is not currently supported in contracts deployed\n   *      using create_with_code_of(). It is called once by the factory during contract creation.\n   */\n  constructor(address token_addr, address uniswap_factory) public {\n    require( \n      address(factory) == address(0) && address(token) == address(0) && token_addr != address(0), \n      \"INVALID_ADDRESS\"\n    );\n    factory = IUniswapFactory(uniswap_factory);\n    token = IERC20(token_addr);\n    name = 0x556e697377617020563100000000000000000000000000000000000000000000;\n    symbol = 0x554e492d56310000000000000000000000000000000000000000000000000000;\n    decimals = 18;\n  }\n\n\n  /***********************************|\n  |        Exchange Functions         |\n  |__________________________________*/\n\n\n  /**\n   * @notice Convert ETH to Tokens.\n   * @dev User specifies exact input (msg.value).\n   * @dev User cannot specify minimum output or deadline.\n   */\n  function () external payable {\n    ethToTokenInput(msg.value, 1, block.timestamp, msg.sender, msg.sender);\n  }\n\n /**\n   * @dev Pricing function for converting between ETH && Tokens.\n   * @param input_amount Amount of ETH or Tokens being sold.\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\n   * @return Amount of ETH or Tokens bought.\n   */\n  function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) public pure returns (uint256) {\n    require(input_reserve > 0 && output_reserve > 0, \"INVALID_VALUE\");\n    uint256 input_amount_with_fee = input_amount.mul(997);\n    uint256 numerator = input_amount_with_fee.mul(output_reserve);\n    uint256 denominator = input_reserve.mul(1000).add(input_amount_with_fee);\n    return numerator / denominator;\n  }\n\n /**\n   * @dev Pricing function for converting between ETH && Tokens.\n   * @param output_amount Amount of ETH or Tokens being bought.\n   * @param input_reserve Amount of ETH or Tokens (input type) in exchange reserves.\n   * @param output_reserve Amount of ETH or Tokens (output type) in exchange reserves.\n   * @return Amount of ETH or Tokens sold.\n   */\n  function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) public pure returns (uint256) {\n    require(input_reserve > 0 && output_reserve > 0);\n    uint256 numerator = input_reserve.mul(output_amount).mul(1000);\n    uint256 denominator = (output_reserve.sub(output_amount)).mul(997);\n    return (numerator / denominator).add(1);\n  }\n\n  function ethToTokenInput(uint256 eth_sold, uint256 min_tokens, uint256 deadline, address buyer, address recipient) private returns (uint256) {\n    require(deadline >= block.timestamp && eth_sold > 0 && min_tokens > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 tokens_bought = getInputPrice(eth_sold, address(this).balance.sub(eth_sold), token_reserve);\n    require(tokens_bought >= min_tokens);\n    require(token.transfer(recipient, tokens_bought));\n    emit TokenPurchase(buyer, eth_sold, tokens_bought);\n    return tokens_bought;\n  }\n\n  /** \n   * @notice Convert ETH to Tokens.\n   * @dev User specifies exact input (msg.value) && minimum output.\n   * @param min_tokens Minimum Tokens bought.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return Amount of Tokens bought.\n   */ \n  function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) public payable returns (uint256) {\n    return ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, msg.sender);\n  }\n\n  /** \n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\n   * @dev User specifies exact input (msg.value) && minimum output\n   * @param min_tokens Minimum Tokens bought.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output Tokens.\n   * @return  Amount of Tokens bought.\n   */\n  function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) public payable returns(uint256) {\n    require(recipient != address(this) && recipient != address(0));\n    return ethToTokenInput(msg.value, min_tokens, deadline, msg.sender, recipient);\n  }\n\n  function ethToTokenOutput(uint256 tokens_bought, uint256 max_eth, uint256 deadline, address payable buyer, address recipient) private returns (uint256) {\n    require(deadline >= block.timestamp && tokens_bought > 0 && max_eth > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_sold = getOutputPrice(tokens_bought, address(this).balance.sub(max_eth), token_reserve);\n    // Throws if eth_sold > max_eth\n    uint256 eth_refund = max_eth.sub(eth_sold);\n    if (eth_refund > 0) {\n      buyer.transfer(eth_refund);\n    }\n    require(token.transfer(recipient, tokens_bought));\n    emit TokenPurchase(buyer, eth_sold, tokens_bought);\n    return eth_sold;\n  }\n\n  /** \n   * @notice Convert ETH to Tokens.\n   * @dev User specifies maximum input (msg.value) && exact output.\n   * @param tokens_bought Amount of tokens bought.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return Amount of ETH sold.\n   */\n  function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) public payable returns(uint256) {\n    return ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, msg.sender);\n  }\n\n  /** \n   * @notice Convert ETH to Tokens && transfers Tokens to recipient.\n   * @dev User specifies maximum input (msg.value) && exact output.\n   * @param tokens_bought Amount of tokens bought.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output Tokens.\n   * @return Amount of ETH sold.\n   */\n  function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) public payable returns (uint256) {\n    require(recipient != address(this) && recipient != address(0));\n    return ethToTokenOutput(tokens_bought, msg.value, deadline, msg.sender, recipient);\n  }\n\n  function tokenToEthInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address buyer, address payable recipient) private returns (uint256) {\n    require(deadline >= block.timestamp && tokens_sold > 0 && min_eth > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\n    uint256 wei_bought = eth_bought;\n    require(wei_bought >= min_eth);\n    recipient.transfer(wei_bought);\n    require(token.transferFrom(buyer, address(this), tokens_sold));\n    emit EthPurchase(buyer, tokens_sold, wei_bought);\n    return wei_bought;\n  }\n\n  /** \n   * @notice Convert Tokens to ETH.\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_eth Minimum ETH purchased.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return Amount of ETH bought.\n   */\n  function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) public returns (uint256) {\n    return tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, msg.sender);\n  }\n\n  /** \n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_eth Minimum ETH purchased.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @return  Amount of ETH bought.\n   */\n  function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address payable recipient) public returns (uint256) {\n    require(recipient != address(this) && recipient != address(0));\n    return tokenToEthInput(tokens_sold, min_eth, deadline, msg.sender, recipient);\n  }\n\n  \n  function tokenToEthOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address buyer, address payable recipient) private returns (uint256) {\n    require(deadline >= block.timestamp && eth_bought > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);\n    // tokens sold is always > 0\n    require(max_tokens >= tokens_sold);\n    recipient.transfer(eth_bought);\n    require(token.transferFrom(buyer, address(this), tokens_sold));\n    emit EthPurchase(buyer, tokens_sold, eth_bought);\n    return tokens_sold;\n  }\n\n  /** \n   * @notice Convert Tokens to ETH.\n   * @dev User specifies maximum input && exact output.\n   * @param eth_bought Amount of ETH purchased.\n   * @param max_tokens Maximum Tokens sold.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return Amount of Tokens sold.\n   */\n  function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) public returns (uint256) {\n    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, msg.sender);\n  }\n\n  /**\n   * @notice Convert Tokens to ETH && transfers ETH to recipient.\n   * @dev User specifies maximum input && exact output.\n   * @param eth_bought Amount of ETH purchased.\n   * @param max_tokens Maximum Tokens sold.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @return Amount of Tokens sold.\n   */\n  function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address payable recipient) public returns (uint256) {\n    require(recipient != address(this) && recipient != address(0));\n    return tokenToEthOutput(eth_bought, max_tokens, deadline, msg.sender, recipient);\n  }\n\n  function tokenToTokenInput(\n    uint256 tokens_sold, \n    uint256 min_tokens_bought, \n    uint256 min_eth_bought, \n    uint256 deadline,\n    address buyer, \n    address recipient, \n    address payable exchange_addr) \n    private returns (uint256) \n  {\n    require(deadline >= block.timestamp && tokens_sold > 0 && min_tokens_bought > 0 && min_eth_bought > 0);\n    require(exchange_addr != address(this) && exchange_addr != address(0));\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\n    uint256 wei_bought = eth_bought;\n    require(wei_bought >= min_eth_bought);\n    require(token.transferFrom(buyer, address(this), tokens_sold));\n    uint256 tokens_bought = IUniswapExchange(exchange_addr).ethToTokenTransferInput.value(wei_bought)(min_tokens_bought, deadline, recipient);\n    emit EthPurchase(buyer, tokens_sold, wei_bought);\n    return tokens_bought;\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (token_addr).\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param token_addr The address of the token being purchased.\n   * @return Amount of Tokens (token_addr) bought.\n   */\n  function tokenToTokenSwapInput(\n    uint256 tokens_sold, \n    uint256 min_tokens_bought, \n    uint256 min_eth_bought, \n    uint256 deadline, \n    address token_addr) \n    public returns (uint256) \n  {\n    address payable exchange_addr = factory.getExchange(token_addr);\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\n   *         Tokens (token_addr) to recipient.\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @param token_addr The address of the token being purchased.\n   * @return Amount of Tokens (token_addr) bought.\n   */\n  function tokenToTokenTransferInput(\n    uint256 tokens_sold, \n    uint256 min_tokens_bought, \n    uint256 min_eth_bought, \n    uint256 deadline, \n    address recipient, \n    address token_addr) \n    public returns (uint256) \n  {\n    address payable exchange_addr = factory.getExchange(token_addr);\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr);\n  }\n\n  function tokenToTokenOutput(\n    uint256 tokens_bought, \n    uint256 max_tokens_sold, \n    uint256 max_eth_sold, \n    uint256 deadline, \n    address buyer, \n    address recipient, \n    address payable exchange_addr) \n    private returns (uint256) \n  {\n    require(deadline >= block.timestamp && (tokens_bought > 0 && max_eth_sold > 0));\n    require(exchange_addr != address(this) && exchange_addr != address(0));\n    uint256 eth_bought = IUniswapExchange(exchange_addr).getEthToTokenOutputPrice(tokens_bought);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 tokens_sold = getOutputPrice(eth_bought, token_reserve, address(this).balance);\n    // tokens sold is always > 0\n    require(max_tokens_sold >= tokens_sold && max_eth_sold >= eth_bought);\n    require(token.transferFrom(buyer, address(this), tokens_sold));\n    IUniswapExchange(exchange_addr).ethToTokenTransferOutput.value(eth_bought)(tokens_bought, deadline, recipient);\n    emit EthPurchase(buyer, tokens_sold, eth_bought);\n    return tokens_sold;\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (token_addr).\n   * @dev User specifies maximum input && exact output.\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\n   * @param max_tokens_sold Maximum Tokens (token) sold.\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param token_addr The address of the token being purchased.\n   * @return Amount of Tokens (token) sold.\n   */\n  function tokenToTokenSwapOutput(\n    uint256 tokens_bought, \n    uint256 max_tokens_sold, \n    uint256 max_eth_sold, \n    uint256 deadline, \n    address token_addr) \n    public returns (uint256) \n  {\n    address payable exchange_addr = factory.getExchange(token_addr);\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (token_addr) && transfers\n   *         Tokens (token_addr) to recipient.\n   * @dev User specifies maximum input && exact output.\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\n   * @param max_tokens_sold Maximum Tokens (token) sold.\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @param token_addr The address of the token being purchased.\n   * @return Amount of Tokens (token) sold.\n   */\n  function tokenToTokenTransferOutput(\n    uint256 tokens_bought, \n    uint256 max_tokens_sold, \n    uint256 max_eth_sold, \n    uint256 deadline, \n    address recipient, \n    address token_addr) \n    public returns (uint256) \n  {\n    address payable exchange_addr = factory.getExchange(token_addr);\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\n   * @dev Allows trades through contracts that were not deployed from the same factory.\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param exchange_addr The address of the exchange for the token being purchased.\n   * @return Amount of Tokens (exchange_addr.token) bought.\n   */\n  function tokenToExchangeSwapInput(\n    uint256 tokens_sold, \n    uint256 min_tokens_bought, \n    uint256 min_eth_bought, \n    uint256 deadline, \n    address payable exchange_addr) \n    public returns (uint256) \n  {\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, msg.sender, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\n   *         Tokens (exchange_addr.token) to recipient.\n   * @dev Allows trades through contracts that were not deployed from the same factory.\n   * @dev User specifies exact input && minimum output.\n   * @param tokens_sold Amount of Tokens sold.\n   * @param min_tokens_bought Minimum Tokens (token_addr) purchased.\n   * @param min_eth_bought Minimum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @param exchange_addr The address of the exchange for the token being purchased.\n   * @return Amount of Tokens (exchange_addr.token) bought.\n   */\n  function tokenToExchangeTransferInput(\n    uint256 tokens_sold, \n    uint256 min_tokens_bought, \n    uint256 min_eth_bought, \n    uint256 deadline, \n    address recipient, \n    address payable exchange_addr) \n    public returns (uint256) \n  {\n    require(recipient != address(this));\n    return tokenToTokenInput(tokens_sold, min_tokens_bought, min_eth_bought, deadline, msg.sender, recipient, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token).\n   * @dev Allows trades through contracts that were not deployed from the same factory.\n   * @dev User specifies maximum input && exact output.\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\n   * @param max_tokens_sold Maximum Tokens (token) sold.\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param exchange_addr The address of the exchange for the token being purchased.\n   * @return Amount of Tokens (token) sold.\n   */\n  function tokenToExchangeSwapOutput(\n    uint256 tokens_bought, \n    uint256 max_tokens_sold, \n    uint256 max_eth_sold, \n    uint256 deadline, \n    address payable exchange_addr) \n    public returns (uint256) \n  {\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, msg.sender, exchange_addr);\n  }\n\n  /**\n   * @notice Convert Tokens (token) to Tokens (exchange_addr.token) && transfers\n   *         Tokens (exchange_addr.token) to recipient.\n   * @dev Allows trades through contracts that were not deployed from the same factory.\n   * @dev User specifies maximum input && exact output.\n   * @param tokens_bought Amount of Tokens (token_addr) bought.\n   * @param max_tokens_sold Maximum Tokens (token) sold.\n   * @param max_eth_sold Maximum ETH purchased as intermediary.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @param recipient The address that receives output ETH.\n   * @param exchange_addr The address of the exchange for the token being purchased.\n   * @return Amount of Tokens (token) sold.\n   */\n  function tokenToExchangeTransferOutput(\n    uint256 tokens_bought, \n    uint256 max_tokens_sold, \n    uint256 max_eth_sold, \n    uint256 deadline, \n    address recipient, \n    address payable exchange_addr) \n    public returns (uint256) \n  {\n    require(recipient != address(this));\n    return tokenToTokenOutput(tokens_bought, max_tokens_sold, max_eth_sold, deadline, msg.sender, recipient, exchange_addr);\n  }\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @notice Public price function for ETH to Token trades with an exact input.\n   * @param eth_sold Amount of ETH sold.\n   * @return Amount of Tokens that can be bought with input ETH.\n   */\n  function getEthToTokenInputPrice(uint256 eth_sold) public view returns (uint256) {\n    require(eth_sold > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    return getInputPrice(eth_sold, address(this).balance, token_reserve);\n  }\n\n  /**\n   * @notice Public price function for ETH to Token trades with an exact output.\n   * @param tokens_bought Amount of Tokens bought.\n   * @return Amount of ETH needed to buy output Tokens.\n   */\n  function getEthToTokenOutputPrice(uint256 tokens_bought) public view returns (uint256) {\n    require(tokens_bought > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_sold = getOutputPrice(tokens_bought, address(this).balance, token_reserve);\n    return eth_sold;\n  }\n\n  /**\n   * @notice Public price function for Token to ETH trades with an exact input.\n   * @param tokens_sold Amount of Tokens sold.\n   * @return Amount of ETH that can be bought with input Tokens.\n   */\n  function getTokenToEthInputPrice(uint256 tokens_sold) public view returns (uint256) {\n    require(tokens_sold > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_bought = getInputPrice(tokens_sold, token_reserve, address(this).balance);\n    return eth_bought;\n  }\n\n  /**\n   * @notice Public price function for Token to ETH trades with an exact output.\n   * @param eth_bought Amount of output ETH.\n   * @return Amount of Tokens needed to buy output ETH.\n   */\n  function getTokenToEthOutputPrice(uint256 eth_bought) public view returns (uint256) {\n    require(eth_bought > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    return getOutputPrice(eth_bought, token_reserve, address(this).balance);\n  }\n\n  /** \n   * @return Address of Token that is sold on this exchange.\n   */\n  function tokenAddress() public view returns (address) {\n    return address(token);\n  }\n\n  /**\n   * @return Address of factory that created this exchange.\n   */\n  function factoryAddress() public view returns (address) {\n    return address(factory);\n  }\n\n\n  /***********************************|\n  |        Liquidity Functions        |\n  |__________________________________*/\n\n  /** \n   * @notice Deposit ETH && Tokens (token) at current ratio to mint UNI tokens.\n   * @dev min_liquidity does nothing when total UNI supply is 0.\n   * @param min_liquidity Minimum number of UNI sender will mint if total UNI supply is greater than 0.\n   * @param max_tokens Maximum number of tokens deposited. Deposits max amount if total UNI supply is 0.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return The amount of UNI minted.\n   */\n  function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) public payable returns (uint256) {\n    require(deadline > block.timestamp && max_tokens > 0 && msg.value > 0, 'UniswapExchange#addLiquidity: INVALID_ARGUMENT');\n    uint256 total_liquidity = _totalSupply;\n\n    if (total_liquidity > 0) {\n      require(min_liquidity > 0);\n      uint256 eth_reserve = address(this).balance.sub(msg.value);\n      uint256 token_reserve = token.balanceOf(address(this));\n      uint256 token_amount = (msg.value.mul(token_reserve) / eth_reserve).add(1);\n      uint256 liquidity_minted = msg.value.mul(total_liquidity) / eth_reserve;\n      require(max_tokens >= token_amount && liquidity_minted >= min_liquidity);\n      _balances[msg.sender] = _balances[msg.sender].add(liquidity_minted);\n      _totalSupply = total_liquidity.add(liquidity_minted);\n      require(token.transferFrom(msg.sender, address(this), token_amount));\n      emit AddLiquidity(msg.sender, msg.value, token_amount);\n      emit Transfer(address(0), msg.sender, liquidity_minted);\n      return liquidity_minted;\n\n    } else {\n      require(address(factory) != address(0) && address(token) != address(0) && msg.value >= 1000000000, \"INVALID_VALUE\");\n      require(factory.getExchange(address(token)) == address(this));\n      uint256 token_amount = max_tokens;\n      uint256 initial_liquidity = address(this).balance;\n      _totalSupply = initial_liquidity;\n      _balances[msg.sender] = initial_liquidity;\n      require(token.transferFrom(msg.sender, address(this), token_amount));\n      emit AddLiquidity(msg.sender, msg.value, token_amount);\n      emit Transfer(address(0), msg.sender, initial_liquidity);\n      return initial_liquidity;\n    }\n  }\n\n  /**\n   * @dev Burn UNI tokens to withdraw ETH && Tokens at current ratio.\n   * @param amount Amount of UNI burned.\n   * @param min_eth Minimum ETH withdrawn.\n   * @param min_tokens Minimum Tokens withdrawn.\n   * @param deadline Time after which this transaction can no longer be executed.\n   * @return The amount of ETH && Tokens withdrawn.\n   */\n  function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) public returns (uint256, uint256) {\n    require(amount > 0 && deadline > block.timestamp && min_eth > 0 && min_tokens > 0);\n    uint256 total_liquidity = _totalSupply;\n    require(total_liquidity > 0);\n    uint256 token_reserve = token.balanceOf(address(this));\n    uint256 eth_amount = amount.mul(address(this).balance) / total_liquidity;\n    uint256 token_amount = amount.mul(token_reserve) / total_liquidity;\n    require(eth_amount >= min_eth && token_amount >= min_tokens);\n\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    _totalSupply = total_liquidity.sub(amount);\n    msg.sender.transfer(eth_amount);\n    require(token.transfer(msg.sender, token_amount));\n    emit RemoveLiquidity(msg.sender, eth_amount, token_amount);\n    emit Transfer(msg.sender, address(0), amount);\n    return (eth_amount, token_amount);\n  }\n\n\n}",
		"test-contracts/MockUniswap/UniswapERC20.sol": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract UniswapERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) internal _balances;\n\n    mapping (address => mapping (address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n",
		"@openzeppelin/contracts/GSN/Context.sol": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n",
		"@openzeppelin/contracts/token/ERC20/IERC20.sol": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",
		"@openzeppelin/contracts/math/SafeMath.sol": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n",
		"test-contracts/MockUniswap/IUniswapFactory.sol": "pragma solidity ^0.5.13;\n\n\ncontract IUniswapFactory {\n    // Events\n    event NewExchange(address indexed token, address indexed exchange);\n    // Public Variables\n    uint256 public tokenCount;\n    // Create Exchange\n    function createExchange(address token, address payable exchange) external returns (address payable);\n    // Get Exchange and Token Info\n    function getExchange(address token) external view returns (address payable exchange);\n    function getToken(address payable exchange) external view returns (address token);\n    function getTokenWithId(uint256 tokenId) external view returns (address token);\n}",
		"test-contracts/MockUniswap/IUniswapExchange.sol": "pragma solidity ^0.5.13;\n\n\ncontract IUniswapExchange {\n    // Events\n    event TokenPurchase(address indexed buyer, uint256 indexed eth_sold, uint256 indexed tokens_bought);\n    event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought);\n    event AddLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\n    event RemoveLiquidity(address indexed provider, uint256 indexed eth_amount, uint256 indexed token_amount);\n    // Address of ERC20 token sold on this exchange\n    function tokenAddress() external view returns (address token);\n    // Address of Uniswap Factory\n    function factoryAddress() external view returns (address factory);\n    // Provide Liquidity\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);\n    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);\n    // Get Prices\n    function getEthToTokenInputPrice(uint256 eth_sold) external view returns (uint256 tokens_bought);\n    function getEthToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256 eth_sold);\n    function getTokenToEthInputPrice(uint256 tokens_sold) external view returns (uint256 eth_bought);\n    function getTokenToEthOutputPrice(uint256 eth_bought) external view returns (uint256 tokens_sold);\n    // Trade ETH to ERC20\n    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);\n    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);\n    // Trade ERC20 to ETH\n    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);\n    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);\n    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);\n    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);\n    // Trade ERC20 to ERC20\n    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);\n    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);\n    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);\n    // Trade ERC20 to Custom Pool\n    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);\n    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);\n    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);\n    // ERC20 comaptibility for liquidity tokens\n    bytes32 public name;\n    bytes32 public symbol;\n    uint256 public decimals;\n    function transfer(address _to, uint256 _value) external returns (bool);\n    function transferFrom(address _from, address _to, uint256 value) external returns (bool);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function allowance(address _owner, address _spender) external view returns (uint256);\n    function balanceOf(address _owner) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    // Never use\n    function setup(address token_addr) external;\n}"
	},
	"sourceTreeHashHex": "0x285de83d7f9c569dc70b46c76620aabe06776f9da923319cbd731b783562f3d5",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.13+commit.5b0b510c.js",
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			},
			"evmVersion": "constantinople",
			"remappings": [
				"@openzeppelin/contracts=/Users/kimbui/Documents/Code/erasure-protocol/node_modules/@openzeppelin/contracts"
			]
		}
	},
	"networks": {}
}