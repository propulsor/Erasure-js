{
	"schemaVersion": "2.0.0",
	"contractName": "Spawner",
	"compilerOutput": {
		"abi": [],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x6080604052348015600f57600080fd5b50603e80601d6000396000f3fe6080604052600080fdfea265627a7a72315820c96113ab414e85e86ed6e60b802e23fb78a384e89423954d445941f5f139fd4d64736f6c634300050d0032",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x3E DUP1 PUSH1 0x1D PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x0 DUP1 REVERT INVALID LOG2 PUSH6 0x627A7A723158 KECCAK256 0xC9 PUSH2 0x13AB COINBASE 0x4E DUP6 0xE8 PUSH15 0xD6E60B802E23FB78A384E89423954D DIFFICULTY MSIZE COINBASE CREATE2 CALL CODECOPY REVERT 0x4D PUSH5 0x736F6C6343 STOP SDIV 0xD STOP ORIGIN ",
				"sourceMap": "1631:11411:22:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;1631:11411:22;;;;;;;"
			}
		}
	},
	"sources": {
		"modules/Spawner.sol": {
			"id": 22
		}
	},
	"sourceCodes": {
		"modules/Spawner.sol": "pragma solidity ^0.5.13;\n\n\n/// @title Spawn\n/// @author 0age (@0age) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This contract provides creation code that is used by Spawner in order\n/// to initialize and deploy eip-1167 minimal proxies for a given logic contract.\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\n/// @title Spawner\n/// @author 0age (@0age) and Stephane Gosselin (@thegostep) for Numerai Inc\n/// @dev Security contact: security@numer.ai\n/// @dev Version: 1.3.0\n/// @notice This contract spawns and initializes eip-1167 minimal proxies that\n/// point to existing logic contracts. The logic contracts need to have an\n/// initializer function that should only callable when no contract exists at\n/// their current address (i.e. it is being `DELEGATECALL`ed from a constructor).\ncontract Spawner {\n  \n  /// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return The address of the newly-spawned contract.\n  function _spawn(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n\n    // get instance code and hash\n\n    bytes memory initCode;\n    bytes32 initCodeHash;\n    (initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid create2 target\n\n    (address target, bytes32 safeSalt) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\n\n    // spawn create2 instance and validate\n\n    return _executeSpawnCreate2(initCode, safeSalt, target);\n  }\n\n  /// @notice Internal function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @param salt bytes32 A user defined salt.\n  /// @return The address of the newly-spawned contract.\n  function _spawnSalty(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal returns (address spawnedContract) {\n\n    // get instance code and hash\n\n    bytes memory initCode;\n    bytes32 initCodeHash;\n    (initCode, initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid create2 target\n\n    (address target, bytes32 safeSalt, bool validity) = _getSaltyTargetWithInitCodeHash(creator, initCodeHash, salt);\n    require(validity, \"contract already deployed with supplied salt\");\n\n    // spawn create2 instance and validate\n\n    return _executeSpawnCreate2(initCode, safeSalt, target);\n  }\n\n  /// @notice Private function for spawning an eip-1167 minimal proxy using `CREATE2`.\n  /// Reverts with appropriate error string if deployment is unsuccessful.\n  /// @param initCode bytes The spawner code and initialization calldata.\n  /// @param safeSalt bytes32 A valid salt hashed with creator address.\n  /// @param target address The expected address of the proxy.\n  /// @return The address of the newly-spawned contract.\n  function _executeSpawnCreate2(bytes memory initCode, bytes32 safeSalt, address target) private returns (address spawnedContract) {\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue,                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        safeSalt                              // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize)\n        revert(0, returndatasize)\n      }\n    }\n\n    // validate spawned instance matches target\n    require(spawnedContract == target, \"attempted deployment to unexpected address\");\n\n    // explicit return\n    return spawnedContract;\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// salt, and initialization calldata payload.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @param salt bytes32 A user defined salt.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return validity bool True if the `target` is available.\n  function _getSaltyTarget(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata,\n    bytes32 salt\n  ) internal view returns (address target, bool validity) {\n\n    // get initialization code\n\n    bytes32 initCodeHash;\n    ( , initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid target\n\n    (target, , validity) = _getSaltyTargetWithInitCodeHash(creator, initCodeHash, salt);\n\n    // explicit return\n    return (target, validity);\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and salt.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @param salt bytes32 A user defined salt.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  /// @return validity bool True if the `target` is available.\n  function _getSaltyTargetWithInitCodeHash(\n    address creator,\n    bytes32 initCodeHash,\n    bytes32 salt\n  ) private view returns (address target, bytes32 safeSalt, bool validity) {\n    // get safeSalt from input\n    safeSalt = keccak256(abi.encodePacked(creator, salt));\n\n    // get expected target\n    target = _computeTargetWithCodeHash(initCodeHash, safeSalt);\n\n    // get target validity\n    validity = _getTargetValidity(target);\n\n    // explicit return\n    return (target, safeSalt, validity);\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// nonce, and initialization calldata payload.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return target address The address of the newly-spawned contract.\n  function _getNextNonceTarget(\n    address creator,\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n\n    // get initialization code\n\n    bytes32 initCodeHash;\n    ( , initCodeHash) = _getInitCodeAndHash(logicContract, initializationCalldata);\n\n    // get valid target\n\n    (target, ) = _getNextNonceTargetWithInitCodeHash(creator, initCodeHash);\n\n    // explicit return\n    return target;\n  }\n\n  /// @notice Internal view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given initCodeHash, and nonce.\n  /// @param creator address The address of the account creating the proxy.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @return target address The address of the newly-spawned contract.\n  /// @return safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  function _getNextNonceTargetWithInitCodeHash(\n    address creator,\n    bytes32 initCodeHash\n  ) private view returns (address target, bytes32 safeSalt) {\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n\n    while (true) {\n      // get safeSalt from nonce\n      safeSalt = keccak256(abi.encodePacked(creator, nonce));\n\n      // get expected target\n      target = _computeTargetWithCodeHash(initCodeHash, safeSalt);\n\n      // validate no contract already deployed to the target address.\n      // exit the loop if no contract is deployed to the target address.\n      // otherwise, increment the nonce and derive a new salt.\n      if (_getTargetValidity(target))\n        break;\n      else\n        nonce++;\n    }\n    \n    // explicit return\n    return (target, safeSalt);\n  }\n\n  /// @notice Private pure function for obtaining the initCode and the initCodeHash of `logicContract` and `initializationCalldata`.\n  /// @param logicContract address The address of the logic contract.\n  /// @param initializationCalldata bytes The calldata that will be supplied to\n  /// the `DELEGATECALL` from the spawned contract to the logic contract during\n  /// contract creation.\n  /// @return initCode bytes The spawner code and initialization calldata.\n  /// @return initCodeHash bytes32 The hash of initCode.\n  function _getInitCodeAndHash(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) private pure returns (bytes memory initCode, bytes32 initCodeHash) {\n    // place creation code and constructor args of contract to spawn in memory.\n    initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get the keccak256 hash of the init code for address derivation.\n    initCodeHash = keccak256(initCode);\n\n    // explicit return\n    return (initCode, initCodeHash);\n  }\n  \n  /// @notice Private view function for finding the expected address of the standard\n  /// eip-1167 minimal proxy created using `CREATE2` with a given logic contract,\n  /// salt, and initialization calldata payload.\n  /// @param initCodeHash bytes32 The hash of initCode.\n  /// @param safeSalt bytes32 A safe salt. Must include the msg.sender address for front-running protection.\n  /// @return The address of the proxy contract with the given parameters.\n  function _computeTargetWithCodeHash(\n    bytes32 initCodeHash,\n    bytes32 safeSalt\n  ) private view returns (address target) {\n    return address(    // derive the target deployment address.\n      uint160(                   // downcast to match the address type.\n        uint256(                 // cast to uint to truncate upper digits.\n          keccak256(             // compute CREATE2 hash using 4 inputs.\n            abi.encodePacked(    // pack all inputs to the hash together.\n              bytes1(0xff),      // pass in the control character.\n              address(this),     // pass in the address of this contract.\n              safeSalt,          // pass in the safeSalt from above.\n              initCodeHash       // pass in hash of contract creation code.\n            )\n          )\n        )\n      )\n    );\n  }\n\n  /// @notice Private view function to validate if the `target` address is an available deployment address.\n  /// @param target address The address to validate.\n  /// @return validity bool True if the `target` is available.\n  function _getTargetValidity(address target) private view returns (bool validity) {\n    // validate no contract already deployed to the target address.\n    uint256 codeSize;\n    assembly { codeSize := extcodesize(target) }\n    return codeSize == 0;\n  }\n}\n"
	},
	"sourceTreeHashHex": "0x8e095840b33edb56bf686e6807b29f210c962dcc91c631d2b917d645bce0bdfb",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.13+commit.5b0b510c.js",
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			},
			"evmVersion": "constantinople",
			"remappings": [
				"@openzeppelin/contracts=/Users/kimbui/Documents/Code/erasure-protocol/node_modules/@openzeppelin/contracts"
			]
		}
	},
	"networks": {}
}