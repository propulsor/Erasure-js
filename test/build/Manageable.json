{
	"schemaVersion": "2.0.0",
	"contractName": "Manageable",
	"compilerOutput": {
		"abi": [
			{
				"inputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "previousManager",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "newManager",
						"type": "address"
					}
				],
				"name": "ManagementTransferred",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "previousOwner",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "newOwner",
						"type": "address"
					}
				],
				"name": "OwnershipTransferred",
				"type": "event"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "isManagerOrOwner",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "isOwner",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "manager",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": true,
				"inputs": [],
				"name": "owner",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"payable": false,
				"stateMutability": "view",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [],
				"name": "renounceManagement",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [],
				"name": "renounceOwnership",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"internalType": "address",
						"name": "newManager",
						"type": "address"
					}
				],
				"name": "transferManagement",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"constant": false,
				"inputs": [
					{
						"internalType": "address",
						"name": "newOwner",
						"type": "address"
					}
				],
				"name": "transferOwnership",
				"outputs": [],
				"payable": false,
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x",
				"opcodes": "",
				"sourceMap": ""
			}
		}
	},
	"sources": {
		"modules/Manageable.sol": {
			"id": 17
		},
		"@openzeppelin/contracts/ownership/Ownable.sol": {
			"id": 53
		},
		"@openzeppelin/contracts/GSN/Context.sol": {
			"id": 51
		}
	},
	"sourceCodes": {
		"modules/Manageable.sol": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an owner and a manager that can be granted exclusive access to\n * specific functions.\n */\ncontract Manageable is Ownable {\n    address private _manager;\n\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial manager.\n     */\n    constructor () internal Ownable() {\n        _manager = _msgSender();\n        emit ManagementTransferred(address(0), _manager);\n    }\n\n    /**\n     * @return the address of the manager.\n     */\n    function manager() public view returns (address) {\n        return _manager;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner or manager.\n     */\n    modifier onlyManagerOrOwner() {\n        require(isManagerOrOwner(), \"Manageable: caller is not the manager or owner\");\n        _;\n    }\n\n    /**\n     * @return true if `msg.sender` is the owner or manager of the contract.\n     */\n    function isManagerOrOwner() public view returns (bool) {\n        return (_msgSender() == _manager || isOwner());\n    }\n\n    /**\n     * @dev Leaves the contract without manager. Owner will need to set a new manager.\n     * Can only be called by the current owner or manager.\n     */\n    function renounceManagement() public onlyManagerOrOwner {\n        emit ManagementTransferred(_manager, address(0));\n        _manager = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newManager.\n     * Can only be called by the current owner.\n     * @param newManager The address to transfer management to.\n     */\n    function transferManagement(address newManager) public onlyOwner {\n        require(newManager != address(0), \"Manageable: new manager is the zero address\");\n        emit ManagementTransferred(_manager, newManager);\n        _manager = newManager;\n    }\n}",
		"@openzeppelin/contracts/ownership/Ownable.sol": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = _msgSender();\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n",
		"@openzeppelin/contracts/GSN/Context.sol": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
	},
	"sourceTreeHashHex": "0x3d1f06a9d5b234a1ebf72704d9a3690c9ab341ceb0fbf1c60762de4672c5d311",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.5.13+commit.5b0b510c.js",
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"evm.bytecode.object"
					]
				}
			},
			"evmVersion": "constantinople",
			"remappings": [
				"@openzeppelin/contracts=/Users/kimbui/Documents/Code/erasure-protocol/node_modules/@openzeppelin/contracts"
			]
		}
	},
	"networks": {}
}